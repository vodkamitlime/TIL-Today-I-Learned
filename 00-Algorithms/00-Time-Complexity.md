# Time Complexity

## Time Complexity (시간복잡도) 란?
- 알고리즘의 로직을 코드로 구현할 때, 입력값에 따라 출력값을 내는데 걸리는 시간의 비율을 의미한다. 
- 시간 복잡도는 보통 Big-O Notation (Big-O 표기법) 을 활용하여 나타낸다. 
	- Big-O Notation 이외에도 Big-Omega(big-Ω),Big-Theta(big-Θ) Notation 등이 존재한다.
	- Big-Omega는 하한선을 기준으로하고, Big-Theta는 상한선과 하한선의 사이를 기준으로 판단한다.
	- 이에 비해 Big-O 는 알고리즘 효율을 상한선 기준으로 표기하기 때문에 자주 사용된다. 즉, 알고리즘을 실행하는데 걸리는 시간의 최대값을 표기한다. 
> 시간 복잡도와 아울러 공간 복잡도 (Space Complexity) 가 자주 논의되곤 하는데, 이는 기억 영역과 파일 공간이 얼마나 필요한가를 평가한 것이다. 

## Big-O Notation 의 특징
1. 상수항은 무시한다.
	- 상수란 변하지 않는 일정한 값을 갖는 숫자를 의미한다. 가령, `2N` 에서 2는 고정된 값이므로 상수이며 N은 변하는 값이므로 변수이다. 
	- Big-O 를 엄밀히 따지면 상수가 붙는 경우가 많으나, 시간복잡도 자체는 입력값인 N에 따라 변하기 때문에 생략한다. 
	- Ex: `O(2N)` -> `N`
2. 영향령이 없는 항은 무시한다. 
	- 위와 같은 이유로 가장 영향력이 큰 항 이외의 부수적인 항들은 생략한다.
	- Ex: `O(N^2 + N + 1)` -> `O(N^2)`

## 주요 성능
[Big-O Functions](https://t1.daumcdn.net/cfile/tistory/99EF1E395C7EB4B601)
- 시간 복잡도의 속도를 한 번에 비교하면 다음과 같다. 
- `O(1) < O(log N) < O(N) < (O N log N) < O(N^2) < O(2^N)`
- 속도가 빠를수록 효율성이 높아지며, 성능이 좋아진다. 따라서 위의 성능 비교에서 O(1) 이 가장 효율성이 높으며, O(2^N) 이 가장 낮다.

### 배운 점:
- 

### 참고 자료
- [빅오 표기법 (big-O notation) 이란](https://noahlogs.tistory.com/27)
