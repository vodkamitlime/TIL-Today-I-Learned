# CH1: From Programming Languages to Program Execution — How It All Works

## 1.1 What If You Invented a Programming Language?
* Switches are composed of 0s and 1s, capable of expressing simple boolean logic.
* A collection of switches, called the CPU, can perform only simple data transfer and arithmetic operations — but at incredibly high speeds.
* Evolution of Computers:
  * **Genesis:** Using punched cards, humans directly wrote instructions made up of 0s and 1s.
  * **Early Stage:** The appearance of **assembly language**, which mapped machine instructions to specific operations, represented with human-readable words.
    * e.g., `add`, `sub`, `mov`
    * Programs were used to translate these human-readable instructions into binary code that the CPU could understand.
  * **Middle Stage:** The transition from low-level to high-level languages.
    * Repetitive patterns in low-level instructions were expressed using *syntax*.
    * Code was structured as a *syntax tree*, where the result of child nodes is passed to their parent nodes.
    * To automatically convert human abstract expressions into concrete CPU-executable implementations, the **compiler** was invented.
  * **Later Stage:** The birth of interpreted languages.
    * Each CPU has its own unique instruction set, so an executable created for one platform (e.g., x86, ARM) cannot run on another.
    * To solve this, a **virtual machine** or **interpreter** was created — a program that defines a standard instruction set and emulates CPU execution behavior.
    * Flow of execution: code → standard instructions → interpreter for each CPU → CPU
    * Based on this idea, languages such as C/C++, Java, and Python were developed.

## 1.2 How Does a Compiler Work?
* A **compiler** is a program that translates a high-level language into a low-level language.
* A text file that contains code is called a **source file**.
* The compiler converts the source file into an **executable file**, which consists of machine instructions that the CPU can execute.
* The translation process:
  * **Lexical Analysis:** Extracts tokens from each element of the source code.
  * **Parsing:** Processes the conditions required to execute each syntactic token.
  * **Syntax Analysis:** Builds a tree structure (syntax tree) from the parsed result.
  * **Semantic Analysis:** Checks for compilation errors and ensures logical consistency.
  * **Intermediate Representation (IR) Generation:** Creates a refined form of code by traversing the syntax tree (some optimizations may also occur during this step).
  ```cpp
  // Source Code
  int a = 1;
  int b = 2;
  while (a < b)
  {
  	b = b - 1;
  }

  // IR Code
  a = 1
  b = 2
  goto B
  A: b = b - 1
  B: if a < b goto A
  ```
  * IR Code → Assembly Code conversion:
  ```cpp
  	.text
  	.globl main
  main:
  	pushq	%rbp
  	movq	%rsp, %rbp

  	# a = 1
  	movl	$0x1, -0x4(%rbp)

  	# b = 2
  	movl	$0x2, -0x8(%rbp)

  	jmp	.LB		# goto B

  .LA:
  	# b = b - 1
  	movl	-0x8(%rbp), %eax
  	subl	$0x1, %eax
  	movl	%eax, -0x8(%rbp)

  .LB:
  	# if (a < b) goto A
  	movl	-0x4(%rbp), %eax
  	cmpl	-0x8(%rbp), %eax
  	jl	.LA		# jump if a < b

  	# function return
  	movl	$0x0, %eax
  	popq	%rbp
  	ret
  ```
  * The **assembly code** is then translated into **machine instructions**.
* The source code is stored in a `.c` file, and the machine instructions are stored in an **object file** (`.o`).
  * Each source file corresponds to its own object file.
  * When there are many source files, the number of object files increases accordingly.
  * The process of combining multiple object files into a single executable is called **linking**, and the program that performs this task is the **linker**.

## 1.3 The Linker’s Untold Secrets
* The role of the **linker** is to combine multiple object files generated by the compiler into a single final executable file.
  * During this process, it verifies that **dependencies** are correctly set.
  * **Symbol Resolution:** A referenced external symbol must have exactly one implementation across all modules. The linker finds this single definition and connects it to all references.
  * The linker also performs **relocation**, which replaces temporary memory addresses with actual addresses in the final executable.

* **Steps of the Linking Process**
  1. **Symbol Resolution**
     * A *symbol* refers to all variable names that include global variables and function names.
     * Local variables are used only within a module and are not referenced externally, so the linker does **not** care about them.
     * The linker checks whether each externally referenced symbol in all object files has a corresponding definition, and ensures that this definition appears exactly once.
  2. **Executable File Generation**
  3. **Relocation**
