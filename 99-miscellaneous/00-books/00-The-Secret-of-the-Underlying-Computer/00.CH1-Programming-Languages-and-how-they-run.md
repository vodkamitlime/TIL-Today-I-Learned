# CH1: From Programming Languages to Program Execution — How It All Works

## 1.1 What If You Invented a Programming Language?
* Switches are composed of 0s and 1s, capable of expressing simple boolean logic.
* A collection of switches, called the CPU, can perform only simple data transfer and arithmetic operations — but at incredibly high speeds.
* Evolution of Computers:
  * **Genesis:** Using punched cards, humans directly wrote instructions made up of 0s and 1s.
  * **Early Stage:** The appearance of **assembly language**, which mapped machine instructions to specific operations, represented with human-readable words.
    * e.g., `add`, `sub`, `mov`
    * Programs were used to translate these human-readable instructions into binary code that the CPU could understand.
  * **Middle Stage:** The transition from low-level to high-level languages.
    * Repetitive patterns in low-level instructions were expressed using *syntax*.
    * Code was structured as a *syntax tree*, where the result of child nodes is passed to their parent nodes.
    * To automatically convert human abstract expressions into concrete CPU-executable implementations, the **compiler** was invented.
  * **Later Stage:** The birth of interpreted languages.
    * Each CPU has its own unique instruction set, so an executable created for one platform (e.g., x86, ARM) cannot run on another.
    * To solve this, a **virtual machine** or **interpreter** was created — a program that defines a standard instruction set and emulates CPU execution behavior.
    * Flow of execution: code → standard instructions → interpreter for each CPU → CPU
    * Based on this idea, languages such as C/C++, Java, and Python were developed.

## 1.2 How Does a Compiler Work?
* A **compiler** is a program that translates a high-level language into a low-level language.
* A text file that contains code is called a **source file**.
* The compiler converts the source file into an **executable file**, which consists of machine instructions that the CPU can execute.
* The translation process:
  * **Lexical Analysis:** Extracts tokens from each element of the source code.
  * **Parsing:** Processes the conditions required to execute each syntactic token.
  * **Syntax Analysis:** Builds a tree structure (syntax tree) from the parsed result.
  * **Semantic Analysis:** Checks for compilation errors and ensures logical consistency.
  * **Intermediate Representation (IR) Generation:** Creates a refined form of code by traversing the syntax tree (some optimizations may also occur during this step).
  ```cpp
  // Source Code
  int a = 1;
  int b = 2;
  while (a < b)
  {
  	b = b - 1;
  }

  // IR Code
  a = 1
  b = 2
  goto B
  A: b = b - 1
  B: if a < b goto A
  ```
  * IR Code → Assembly Code conversion:
  ```cpp
  	.text
  	.globl main
  main:
  	pushq	%rbp
  	movq	%rsp, %rbp

  	# a = 1
  	movl	$0x1, -0x4(%rbp)

  	# b = 2
  	movl	$0x2, -0x8(%rbp)

  	jmp	.LB		# goto B

  .LA:
  	# b = b - 1
  	movl	-0x8(%rbp), %eax
  	subl	$0x1, %eax
  	movl	%eax, -0x8(%rbp)

  .LB:
  	# if (a < b) goto A
  	movl	-0x4(%rbp), %eax
  	cmpl	-0x8(%rbp), %eax
  	jl	.LA		# jump if a < b

  	# function return
  	movl	$0x0, %eax
  	popq	%rbp
  	ret
  ```
  * The **assembly code** is then translated into **machine instructions**.
* The source code is stored in a `.c` file, and the machine instructions are stored in an **object file** (`.o`).
  * Each source file corresponds to its own object file.
  * When there are many source files, the number of object files increases accordingly.
  * The process of combining multiple object files into a single executable is called **linking**, and the program that performs this task is the **linker**.

## 1.3 The Linker’s Untold Secrets
* The role of the **linker** is to combine multiple object files generated by the compiler into a single final executable file.
  * During this process, it verifies that **dependencies** are correctly set.
  * **Symbol Resolution:** A referenced external symbol must have exactly one implementation across all modules. The linker finds this single definition and connects it to all references.
  * The linker also performs **relocation**, which replaces temporary memory addresses with actual addresses in the final executable.

* **Steps of the Linking Process**
## Linking Process Steps

1. **Symbol Resolution**
   * **What is a symbol?** Any variable name that includes global variables and function names.
   * Local variables are used only within their own module and are not referenced by external modules, so the linker **does not care about them**.
   * The linker checks whether every external symbol referenced by an object file has a corresponding definition, and ensures that this definition exists **exactly once**.
   * The linker receives two types of information from the compiler:
     * Symbols **defined** in the source file that may be referenced by other modules
     * Symbols the source file **references** that are defined elsewhere
   * Each object file consists of two major sections:
     * **Data Section:** Stores global variables defined in the source file
     * **Code Section (Text Section):** Stores machine instructions generated from functions defined in the source file
   * The compiler delegates the task of finding definitions of externally defined global variables or functions to the linker; instead, it creates a **symbol table**.
     * The symbol table contains:
       * Symbols *defined* by this module
       * External symbols *referenced* by this module
     * The symbol table is also stored inside the object file.
   * **Symbol resolution** = ensuring that each external symbol referenced by an object file can be matched to a single, unique definition in the symbol tables.

2. **Executable File Generation**
   * **Static Libraries**
     * `.lib` on Windows, `.a` on Linux
     * Individual source files can be compiled separately and then linked together into a single static library.
     * When generating an executable, the necessary parts of the static library are copied into the executable (this is **static linking**).
   * **Static Linking**
     * The linker merges the elements of each object file (code section / data section):
       * Object A code section + Object B code section + Object C code section
       * Object A data section + Object B data section + Object C data section
     * The resulting executable also has code and data sections.
     * The executable contains a special symbol called **`_start`** → the CPU begins execution from the address of this symbol to run the initial machine instructions needed to start the program.
     * After those instructions run, the program eventually transitions into the execution of the `main` function.

3. **Relocation**
