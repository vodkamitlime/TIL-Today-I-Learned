# CH1: From Programming Languages to Program Execution — How It All Works

## 1.1 What If You Invented a Programming Language?

* Switches are composed of 0s and 1s, capable of expressing simple boolean logic.
* A collection of switches, called the CPU, can perform only simple data transfer and arithmetic operations — but at incredibly high speeds.
* Evolution of Computers:
  * **Genesis:** Using punched cards, humans directly wrote instructions made up of 0s and 1s.
  * **Early Stage:** The appearance of **assembly language**, which mapped machine instructions to specific operations, represented with human-readable words.

    * e.g., `add`, `sub`, `mov`
    * Programs were used to translate these human-readable instructions into binary code that the CPU could understand.
  * **Middle Stage:** The transition from low-level to high-level languages.

    * Repetitive patterns in low-level instructions were expressed using *syntax*.
    * Code was structured as a *syntax tree*, where the result of child nodes is passed to their parent nodes.
    * To automatically convert human abstract expressions into concrete CPU-executable implementations, the **compiler** was invented.
  * **Later Stage:** The birth of interpreted languages.

    * Each CPU has its own unique instruction set, so an executable created for one platform (e.g., x86, ARM) cannot run on another.
    * To solve this, a **virtual machine** or **interpreter** was created — a program that defines a standard instruction set and emulates CPU execution behavior.
    * Flow of execution: code → standard instructions → interpreter for each CPU → CPU
    * Based on this idea, languages such as C/C++, Java, and Python were developed.

## 1.2 How Does a Compiler Work?

* A **compiler** is a program that translates a high-level language into a low-level language.
* A text file that contains code is called a **source file**.
* The compiler converts the source file into an **executable file**, which consists of machine instructions that the CPU can run.
* The translation process:

  * **Lexical Analysis:** Extracts tokens from each element of the source code.
  * **Parsing:** Processes the conditions required to execute each syntax token.
  * **Syntax Analysis:** Builds a tree structure (syntax tree) from the parsed structure.
  * **Semantic Analysis:** Checks for compilation errors and ensures logical consistency.
  * **Intermediate Representation (IR) Generation:** Produces a refined form of code based on traversal of the syntax tree.
