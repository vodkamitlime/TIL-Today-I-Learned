## Main Memory Management

### Background
- Types of memory 
    - (High speed, small capacity) Register -> Cache -> Main Memory -> Auxiliary Storage (Low speed, large capacity)
    - HW (CPU) managed: Register, Cache
    - SW (OS) managed: Main Memory, Storage
    - Composed in this structure to resolve I/O bottleneck
- Data transmission unit
    - Register <-**Word**-> Main Memory <-**Block**-> Auxiliary Storage
    - Block
        - data transmission unit between main memory and auxiliary storage
        - Size: 1 ~ 4 kB
        - (Even if you just want to read 1 bit from storage, 1 ~ 4 kB of data is loaded on memory)
    - Word
        - data transmission unit between main memory and register
        - Size: 16 ~ 64 bits
        - (Computer bits ex. 32bit/64bit --> size of Word)
- Address binding
    - Task in which logical address of program is mapped to physical address
    - Binding times
        - Compile time binding
            - When compiler knows where process will be loaded on memory
            - Location is not changed
            - Program must be fully loaded on memory
        - Load time binding
            - When compiler doesn't know where process will be loaded on memory, substitutable relative memory is created (ex. start address : u, variable addresses: u + 100, u + 200...)
            - At load time, start address is applied and user code addresses are all substituted 
            - Program must be fully loaded on memory
        - Run time binding
            - Address binding is delayed until runtime
            - Process can move to another memory address while running
            - Needs help of HW (MMU/Memory Management Unit)
            - Used by most OS
- Dynamic Loading
    - All routines (ex. functions) are saved on disk as substitutable structure
    - Routines are not loaded on memory until actual call
    - Address binding happens when routine is called
- Swapping
    - Swap-out: When processor allocation is over, and process which is finished executing is sent to swap-device (Memory -> Storage)
    - Swap-in: Starting process is loaded on memory (Storage -> Memory)

### Memory Allocation

#### Continuous Memory Allocation
- Policy in which one process (context) is allocated in one continuous memory space (Ex. Program, data, stack)
- Elements to consider
    - Process # that can be loaded on memory at the same time (multiprogramming degree)
    - Size of memory space each process is allocated
    - Memory partitioning method
- Uni-programming
    - Multiprogramming degree = 1
    - Only one program exists on memory
    - Problem #1
        - What if program size > memory size?
        - Use overlay structure
            - Load only necessary areas on memory
            - Divide program into smaller parts
            - User/programmer has to intervene
    - Problem #2
        - How to protect kernel?
        - Use boundary register (boundary address between Kernel and User program)
    - As a result..
        - Low system resource utilization
        - Low system performance
- Multi-programming
    - Multiprogramming degree = Number of Partitions
    - FPM (Fixed Partition Multiprogramming)
        - Memory is allocated beforehand, in fixed sizes
        - Each process is loaded on one partition (1:1)
        - How to protect Kernel and User space?
            - Each partition has boundary register
        - Fragmentation
            - Internal Fragmentation
                - When partition size > Process size, memory is wasted
            - External Fragmentation
                - When leftover total memory size > process size, but not continuous, memory is wasted
        - Low overhead, however system resources may be wasted
    - VPM (Variable Partition Multiprogramming)
        - Memory is dynamically allocated while dealing with processes
        - No internal fragmentation
        - Placement strategies
            - First-fit : first partition that has enough space is selected (low overhead but may have low space utility)
            - Best-fit : smallest partition among ones that have enough space is selected (high overhead)
            - Worst-fit : biggest partition among ones that have enough space is selected (high overhead)
            - Next-fit : start finding from most recent area of state table
        - How to solve external fragmentation?
            - Coalescing holes : Combine adjacent empty spaces to one partition, when memory is released
            - Storage Compaction : Combine all empty spaces to one partition (at the price of stopping & rearranging processes, wastes a lot of system resources)
