# IPC

## Introduction
- Inter-process Communication
- When multiple process is needed to solve a problem, IPC is used to share data
- Main IPC methods
    - Message Queue
    - Shared memory
    - Semaphore
    - Memory mapped file
    - Pipe

## General steps for IPC
1. Create key (name predefined for communication) for IPC
    - 32-bit integer
    - 12bit (device id) + 12bit (I-node number) + 8bit (user defined ID)
    - First 24 bits are file path
    - Which means, key is also a file
    - How to create a key? `key_t ftok(const char *pathname, int proj_id)`
        - proj_id = user defined ID
2. Create IPC object through Identifier (인식자)
    - IPC object: message queue, shared memory, etc... 
    - All IPC methods have common IPC struct called ipc_perm
    ```C
    struct ipc_perm {
        key_t key; // Key for IPC
        uid_t uid; // Effective UID of owner
        gid_t gid; // Effective GID of owner
        uid_t cuid; // Effective UID of creator
        gid_t cgid; // Effective GID of creator
        unsigned short mode; // Permissions
        unsigned short __seq; // Sequence number
    }
    ```
    - Permissions:
        - Process' EUID or GUID = IPC object's uid or gid
    - `ipcs`: shell command to search for ipc object
        - `-m`, `-q`, `-s` to search for information of shared memory/ message queue/ semaphore
3. Communicate via created IPC object
    - Use system call for each IPC method
4. Delete IPC object and terminate
    - `ipcrm object_id`: shell command to delete IPC object

## Process Synchronization
- In multi programming systems, multiple processes exist
- Processes work independently
- When shared resource or data exist, problems may occur
- Synchronization
    - Aligning processes' actions
    - Sharing information among processes
- Mutual Exclusion
    - enterCS() primitive checks if there is another process before entering critical section
    - exitCS() primitive alerts that a process exits the critical section

## Message Queue
- Queue used to give and take messages defined by user
- Differences with pipe: pipe connects streams, but message queue works on message basis
- `int msgget(key_t key, int msgflg)`
    - key: IPC key (can also create private message queue for parent-child communication)
    - msgflg: creation methods & access modifiers
- `int msgsnd(int msgid, const void *msgp, size_t msgsz, int msgflg)`
    - send message
- `ssize_t msgrcv(nt msgid, void *msgp, size_t msgsz, long msgtyp, int msgflg)`
    - receive message

## Shared Memory
- Memory area shared by many different processes
    - They can read/write at the same time
    - Need synchronization
- `int shmget(key_t key, size_t size, int shmflg)`
    - Allocate shared memory segment    

## Semaphore
- Solves problem of busy waiting
- Semaphore is an integer type variable (S) 
- Initalization, P(), V()
    - P() : enterCS()
    - V() : exitCS()
- All operators are supported by OS and are indivisbile. All are performed under one instruction cycle
- One ready queue is allocated to one S variable
- Types of Semaphores
    - Binary semaphore: S has 0 or 1 value only, used for purpose of mutual exclusion or process synchronization
    - Counting semaphore: S has value of 0 or larger, solves producer-consumer problem
- Semaphore in Unix/Linux
    - `int semget()`: creating a semaphore object
    - `semop()` with negative parameter: P()
    - `semop()` with positive parameter: V()
