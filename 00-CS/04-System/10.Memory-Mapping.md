# Memory Mapping

## Background
- Mapping a file into memory: mapping a file to a process' virtual memory
- Pros of memory mapping:
    - Able to access file without I/O (Can read file contents directly from memory)
    - Able to communicate with other processes
        - One process cannot access another process' memory area
        - However, a process can access a file
        - When one process writes to a memory area that is mapped to a file, the same content is written in the file
        - And another process can read the updated content from the file

## System calls
- `void* mmap (void *addr, size_t length, int prot, int flags, int fd, off_t offset)`
    - addr : address hint for memory to map (NULL used normally)
    - length : bytes length to map
    - offset : offset to designate starting point of mapping
        - maps file's data range from file's starting point + offset to length
        - offset must be page size's multiple
    - prot: memory protection mode
        - `PROT_NONE`: cannot access
        - `PROT_READ`
        - `PROT_WRITE`
        - `PROT_EXEC`
        - can combine r/w/x modes with OR opreator
        - prot mode cannot conflict with open mode of FD (ex file that is opened readonly mode cannot be mapped in PROC_WRITE)
    - flags: mapping state and tactic
        - `MAP_FIXED`
        - `MAP_PRIVATE`
        - `MAP_SHARED`
    - fd: file descriptor for file to map
    - returns : memory address allocated
- Mapping occurs in unit of |Page|
    - paging system, page: unit of memory block of process
    - Page: block of divided program
    - Page frame: Divided area of memory, same size as page
    - `getpagesize` system call of linux returns page size
