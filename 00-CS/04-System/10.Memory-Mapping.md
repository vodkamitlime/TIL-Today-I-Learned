# Memory Mapping

## Background
- Mapping a file into memory: mapping a file to a process' virtual memory
- Pros of memory mapping:
    - Able to access file without I/O (Can read file contents directly from memory)
    - Able to communicate with other processes
        - One process cannot access another process' memory area
        - However, a process can access a file
        - When one process writes to a memory area that is mapped to a file, the same content is written in the file
        - And another process can read the updated content from the file

## System calls

### Memory Mapping
- `void* mmap (void *addr, size_t length, int prot, int flags, int fd, off_t offset)`
    - addr : address hint for memory to map (NULL used normally)
    - length : bytes length to map
    - offset : offset to designate starting point of mapping
        - maps file's data range from file's starting point + offset to length
        - offset must be page size's multiple
    - prot: memory protection mode
        - `PROT_NONE`: cannot access
        - `PROT_READ`
        - `PROT_WRITE`
        - `PROT_EXEC`
        - can combine r/w/x modes with OR opreator
        - prot mode cannot conflict with open mode of FD (ex file that is opened readonly mode cannot be mapped in PROC_WRITE)
    - flags: mapping state and tactic
        - `MAP_FIXED` : designate the address to map (if address is already designated for mapping, deallocate it and map again)
        - `MAP_PRIVATE` : updated content is not shared & applied to actual file (work is done in copied memory)
        - `MAP_SHARED` : share the content that is mapped (when mapping is worked in write, it is applied to file)
    - fd: file descriptor for file to map
    - returns : memory address allocated
- Mapping occurs in unit of |Page|
    - paging system, page: unit of memory block of process
    - Page: block of divided program
    - Page frame: Divided area of memory, same size as page
    - `getpagesize` system call of linux returns page size
- Related signals
    - `SIGBUS` : mapping region is invalid
    - `SIGSEGV` : try to write to a read-only mapping region
- File size must be bigger than memory area that is to be used
- Copy on Write (CoW)
    - System delays copying memory until moment of actual write (to increase system efficiency)
    - This makes program able to read data that is applied to mapped file before write 

### Removing a mapping
- `int munmap(void *addr, size_t length);`
    - addr : starting address of mapping
    - length : length of mapping

### Synchronizing a file with a mapping
- System works on memory, and then synchronizes data on specific command (for low system overhead)
- `int msync(void *addr, size_t length, int flags)`
    - flags
        - `MS_SYNC` : wait until write-back is finished
        - `MS_ASYNC` : execute write-back asynchronously, returns without wait
        - `MS_INVALIDATE` : invalidate changes in memory
- Page write-back
    - synchronizing file with memory 
    - similar to fflush()

### Changing file size
- `int truncate(const char *path, off_t length);`
- `int ftruncate(int fd, off_t length)`
- Changes file size
    - initialized with 0
- Need write permission for file
- Used when file size for mapping is small

## IPC via memory mapping
- IPC: Inter-process communication 
- IPC is reached through sharing memory mapping region among processes
- Synchronization among procceses must be considered
- IPC Methods
    - Pipe
    - Message Queue
    - Shared Memory
    - Semaphore
