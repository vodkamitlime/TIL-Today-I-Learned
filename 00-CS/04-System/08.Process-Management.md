# Process Management

## Running a new process
- Executing a new program
    - Read the binary of a program and overwrite the memory area of the process that called itself
    - Original program is stopped
- Creating a new process
    - Copies parent process to a new child process
    - Forking: Can be executed through `fork()` system call
    - Inherits: Information in memory
        - RUID, EUID, RGID, EGID, setuid, setgid
        - Env variables, Opened file descriptors
        - Working directory, Signal handling setup, resource limit, etc
    - Child's unique information
        - PID, PPID
        - TMS Structure
        - Resource information (Resource statics, pending signals, etc...)

## Terminating a process
- When process is terminted, exit status is saved
    - 0 means normal termination
    - Can deliver child process' exit status to parent
- `exit(int status)`
    - status = exit status to deliver to parent process
- Process termination sequence
    - Executes functions registered in `atexit(3)` in reverse order of registration
    - Flushes all contents of Standard IO
    - Deletes all temporal file (`tmpfile()`)
    - Calls `_exit(2)` -> After this, kernel continues on with termination process
        - Closes file descriptors in use
        - Sends exit status to parent process
        - Sends SIGCHLD to child process
        - Sends SIGUP to parent process
        - Returns resources used by process 
- `atexit(void (*function)(void))`
    - Registers functions to be called at exit() or return to main()

## Process Synchronization
- Multi programming system
    - Has multiple processes (independent of each other)
    - Shared resources may cause problems
- Synchronization
    - Processes sharing information, agreeing on specific actions

### Zombie Process/State
- Process which is terminated, but is not deleted yet
- When child process is terminated before parent, it is zombie process
    - Resources are returned
    - But minimum information is kept at kernel (ex. exit status)
    - Remains in zombie state until parent receives the exit status
- How to receive exit status of child process?
    - `wait(int *status)`
        - Waits until child process exits
        - When child process terminates, gets exit status
        - If there are multiple child processes, gets exit status of child that terminates earliest
        - returns -1 if there are no child processes
    - `waitpid(pid_t pid, int *status, int options)`
        - Waits until specific child process exits
        - Options
            - `WNOHANG` : returns status instantly even if child process is running
            - `WNOWAIT` : keeps child process waiting even after acquiring exit status

### Exit Status
- (a) Value delivered to exit (8 bits) + (b) Signal # that terminated the process
    - (a) ex. exit(3) -> 3
    - (a) 0 if abnormal exit
    - (b) 0 if normal exit
- Different from system by system
    - Use macro functions
    - `WIFEXITED` : true if regular exit
    - `WEXITSTATUS` : value of exit()
    - `WIFSIGNALED` : true if exit by signal 
 