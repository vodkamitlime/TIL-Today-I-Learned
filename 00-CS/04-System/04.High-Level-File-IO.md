# High Level File I/O (Standard I/O)

## Disk Address
- Physical address
    - defines sector (cyliner number, surface number, sector number)
- Logical disk address (relative address)
    - treats disk system's data as block sequence
        - numbers blocks
        - is able to access number
- Address mapping
    - OS -> (Block #) -> Disk Driver -> (Physical Addr) -> Disk controller

## Block
- Abstraction of the file system
- 512 ~ 8192 bytes
- sector size < Block Size < Page Size 
- Minimum unit of disk (block) access

## File IO vs Disk IO
- File IO
    - Access in a unit of byte
- Disk IO
    - Access in a unit of block
- Kernel Buffer
    - Kernel manages buffer to write bytes in memory and then writes back in block
    - Page write back timing
        - When kernel's memory space is insufficient
        - some time after content is modifyed
        - fsync() 
    - cannot be predicted by user

## User buffered IO
- `char buf[BLOCK_SIZE]`
- user created buffer, manually write on buffer
- easy to implement, but have to know block sizes, system calls..
- `stdio.h` resolves this issue, easily implements user-buffered IO

## Standard IO
- platform-independent, user-buffering solution
- file pointer
    - pointer that points to struct FILE that manages file operations
    - internally maps with file descriptor
- stream
    - tunnel between program and file

## Open & Close
- opening a file/stream: `fopen`
    - `FILE * fopen (const char *path, const char *mode);`
    - path: file path of file to open
    - mode: file open mode
        - `r`: read
        - `w`: write
        - `a`: append
        - add `+` to switch to another mode (read -> write, write -> read, append -> read)
        - `b`: binary
    - returns: file pointer
        - NULL: fail to open
- closing a file/stream: `fclose`
    - `int fclose(FILE *stream);`
    - stream: stream to close
    - returns: 0 for success, -1 for error

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
    FILE *fp;

    if ((fp = fopen("hello.txt", "w")) == NULL) {
        perror("fopen: hello.txt");
        exit(1);
    }

    fclose(fp);

    return 0;
}
```

## File Access (Read/Write)
- 4 ways to read/write
    - Character
    - String
    - Binary
    - Formatted

### Character-based
- read
    - `int fgetc (FILE *stream);`
        - is function
    - `int getc (FILE *stream);`
        - is macro
    - `int getchar (void);`
        - equals to getc(stdin)
    - parameters:
        - stream: stream to operate
        - c: character to read
        - returns: character read, -1 on error
- write
    - `int fputtc (int c, FILE *stream);`
    - `int puttc (int c, FILE *stream);`
    - `int puttchar (int c);`
    - parameters:
        - stream: stream to operate
        - c: character to write
        - returns: character written, -1 on error

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
    FILE * rfp, *wfp;

    if ((rfp = fopen("hello.txt", "w")) == NULL) {
        perror("fopen: hello.txt");
        exit(1);
    }
    if ((wfp = fopen("hello.txt", "w")) == NULL) {
        perror("fopen: hello.txt");
        exit(1);
    }

    while ((c = fgetc(rfp)) != EOF) {
        fputc(c, wfp);
    }

    fclose(rfp);
    fclose(wfp);

    return 0;
}
```

### String-based
- read
    - `char gets (char * s);`
        - get from stdin, no consideration of buffer size
    - `char fgets (char * s, int n, FILE *stream);`
        - reads n-1 chars from stream and saves to s
        - reads until \n or EOF
    - parameters:
        - s: buffer to save read string
        - n: buffer size
        - stream: stream to operate
        - returns: starting address of buffer, or NULL
- write
    - `int fputs (char *s, FILE *stream);`
        - write s to stream without \n
    - `int puts (char *s);`
        - put to stdout with \n
    - parameters:
        - s: buffer that saves string
        - stream: stream to operate
        - returns: positive number on success, negative on error

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
    FILE * rfp, *wfp;
    char buf[BUFSIZ]; // BUFSIZ defined in stdio.h

    if ((rfp = fopen("hello.txt", "r")) == NULL) {
        perror("fopen: hello.txt");
        exit(1);
    }
    if ((wfp = fopen("hello.txt", "a")) == NULL) {
        perror("fopen: hello.txt");
        exit(1);
    }

    while (fgets(buf, BUFSIZ, rfp) != NULL) {
        fputs(buf, wfp);
    }

    fclose(rfp);
    fclose(wfp);

    return 0;
}
```