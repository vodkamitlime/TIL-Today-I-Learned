# High Level File I/O (Standard I/O)

## Disk Address
- Physical address
    - defines sector (cyliner number, surface number, sector number)
- Logical disk address (relative address)
    - treats disk system's data as block sequence
        - numbers blocks
        - is able to access number
- Address mapping
    - OS -> (Block #) -> Disk Driver -> (Physical Addr) -> Disk controller

## Block
- Abstraction of the file system
- 512 ~ 8192 bytes
- sector size < Block Size < Page Size 
- Minimum unit of disk (block) access

## File IO vs Disk IO
- File IO
    - Access in a unit of byte
- Disk IO
    - Access in a unit of block
- Kernel Buffer
    - Kernel manages buffer to write bytes in memory and then writes back in block
    - Page write back timing
        - When kernel's memory space is insufficient
        - some time after content is modifyed
        - fsync() 
    - cannot be predicted by user

## User buffered IO
- `char buf[BLOCK_SIZE]`
- user created buffer, manually write on buffer
- easy to implement, but have to know block sizes, system calls..
- `stdio.h` resolves this issue, easily implements user-buffered IO

## Standard IO
- platform-independent, user-buffering solution
- file pointer
    - pointer that points to struct FILE that manages file operations
    - internally maps with file descriptor
- stream
    - tunnel between program and file

## Open & Close
- opening a file/stream: `fopen`
    - `FILE * fopen (const char *path, const char *mode);`
    - path: file path of file to open
    - mode: file open mode
        - `r`: read
        - `w`: write
        - `a`: append
        - add `+` to switch to another mode (read -> write, write -> read, append -> read)
        - `b`: binary
    - returns: file pointer
        - NULL: fail to open
- closing a file/stream: `fclose`
    - `int fclose(FILE *stream);`
    - stream: stream to close
    - returns: 0 for success, -1 for error

```c
#include <stdio.h>
#include <stdlib.h>

int main(void) {
    FILE *fp;

    if ((fp = fopen("hello.txt", "w")) == NULL) {
        perror("fopen: hello.txt");
        exit(1);
    }

    fclose(fp);

    return 0;
}
```

## File Access (Read/Write)
- 4 ways to read/write
    - Character
    - String
    - Binary
    - Formatted

### Character-based
- `int fgetc (FILE *stream);`
    - is function
- `int getc (FILE *stream);`
    - is macro
- `int getchar (void);`
    - equals to getc(stdin)
- parameters:
    - stream: stream to operate
    - c: character to write
    - returns: character read, -1 on error
