# Signal

## Background
- Software interrupts that provide a mechanism for handling asynchronous events 
- Interrupt: Unexpected external event, asynchronous event
- Sequence
    1. Interrupts occurs
    2. Process terminates (kernel intervenes)
    3. Interrupt handling
        4. Finds interrupt cause
        5. Decides whether to servicce interrupt
        6. Calls Interrupt service routine

## Life Cycle of Signal
- Raise
    - Exception in program (ex. divide by zero)
    - User input (ex. keyboard)
    - Created & delivered by process/kernel
- Store
    - Kernel stores signal until it is delivered to another process
    - When it becomes available for delivery, it is delivered to other process
- Handle
    - There are many ways to handle the signal
        1. Ignore the signal
        2. Catch/handle the signal
        3. Perform the default action

## Signals in Unix/Linux
- Symbolic constants (map to number)
    - `#include <signal.h>`
    - `man -s 7 signal`
    - Signal number may differ according to system (Use symbolic constants)
- Pending signals: Signals that are not handled yet

## Signal Handler
- Function assigned to handle specific signals
- Default handler is defined, and default handlers can be substituted
    - Except! handlers for:
    - SIGKILL: signal that force kills process
    - SIGSTOP: signal that force stops process 
- How to register signal handler:
    - `sighandler_t signal(int signum, signadler_t handler);`
    - signum: signal number to handle
    - handler: function pointer of signal handler
        - SIG_IGN: ignores signal
        - SIG_DFL: handles with system's default handler
    - returns: function pointer of original handler / function pointer of SIG_ERROR on error

```c
#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <signal.h>

void sigint_handler(int signo)
{
    printf("Caught SIGINT!\n");
    psignal(signo, "Received signal");
}

int main(void)
{
    if (signal(SIGINT, sigint_handler) == SIG_ERR) {
        fprintf(stderr, "Cannot handle SIGINT!\n");
        exit(EXIT_FAILURE);
    }

    for (;;) pause(); // pause(2) : waiting a signal (any signal) for 2 seconds
    return 0;
}
```

## Inherited signal behavior
- On fork() 
    - When parent process creates child process
    - Child inherits parent's signal handling method (except pending signals)
    - Inherits signal handler, ignore, default
- On exec()
    - Terminating current process and running a new one
    - pid is maintained
    - Signal handler is not inherited (ignore, default is inherited)
    - Inherits pending signal

## Sending a signal
- `int kill(pid_t pid, int signo)`
    - pid: process to send signal
        - 0: All processes in the same process group as itself
        - -1: All processes that the current process can send signal with its authorization
        - < -1: process group that is GID == |pid|
    - signo: signal number to send
    - Returns:
        - 0 on success
        - -1: on fail
            - errno = EINVAL -> invalid signo
            - errno = EPERM -> no permission to send signal
            - errno = ESRCH -> process doesn't exist (or process is in zombie state)
- Permission for sending a signal
    - To send signal to another process, right permission is required
    - Needs:
        - Sender's (RUID or EUID) == (RUID or SUID) of the receiver
        - Root can send signal to all processes
    - How to check permission:
        - Send null signal (=0)
            - Doesn't send real signal, but can handle error checking
        ```c
        int ret;
        ret = kill(1722, 0);
        if (ret);   // lacks permission
        else;       // has permission
        ```
```c
extern int errno;

int main(void)
{
    int targetPID = 0;

    while(1) {
        printf("Enter PID to kill : ");
        scanf("%d", &targetPID);
        if (kill(targetPID, SIGKILL) == -1) {
            switch (errno) {
            case EPERM:
                printf("Not enough permission!\n");
                break;
            case ESRCH:
                printf("Cannot find the process %d\n", targetPID);
                break;
            }
        } else {
            printf("Bang! -> %d\n", targetPID);
        }
    }
}
```
- `int raise(int sig);`
    - sending a signal to self
- `int alarm(insigned int seconds);`
    - sending SIGALRM after assigned seconds 

## Blocking signals
- Why block signals?
    - Signal (interrupt) happens in random moment
    - Kernel terminates program in random moment and moves on to signal handling
    - What if process receives signal during important task?
    - Signal blocking is necessary for critical region protection
- Signal set
    - used to handle multiple signals
    - `sigset_t` = bit mask
        - each bit is mapped with signal number
    - There are functions to {empty/fill/add signum to/delete signum from/check if signal exists} in the set 
- `int sigprocmask(int how, const sigset_t *set, sigset_t *oldset)`
    - how: method
        - SIG_SETMASK : apply set as blocking mask
        - SIG_BLOCK : add blocking target
        - SIG_UNBLOCK : removes from blocking targt
    - set : signal set to apply
        - NULL : ignore how (maintain signal mask), current signal mask is returned to old set
    - oldset : returns signal set before applying new signal set
    - pending signals are delivered after blocking is released

## Waiting signals
- `int sigsuspend(const sigset_t *mask)`
    - Temporarily replaces signal mask and waits until unblocked signal is received
    - mask : address of signal set to replace